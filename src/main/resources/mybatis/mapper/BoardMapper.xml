<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!-- 게시판 -->
<mapper namespace="com.example.first.mapper.BoardMapper">

    <resultMap id="boardResultMap" type="com.example.first.dto.BoardDto">
        <id property="boardId" column="board_id"/>
        <result property="userId" column="user_id"/>
        <result property="createdAt" column="created_at"/>
    </resultMap>

    <resultMap id="CommentResultMap" type="com.example.first.dto.CommentDto">
        <id property="commentId" column="comment_id"/>
        <result property="boardId" column="board_id"/>
        <result property="parentCommentId" column="parent_comment_id"/>
        <result property="createdAt" column="created_at"/>
    </resultMap>

    <!-- 게시글 목록 조회 쿼리 -->
    <select id="getAllBoards" resultType="com.example.first.dto.BoardDto" resultMap="boardResultMap">
        SELECT * FROM postgres.first_project.boards
        ORDER BY created_at DESC;
    </select>

    <!-- 특정 게시글 조회 쿼리 -->
    <select id="getBoardById" parameterType="java.lang.Long" resultType="com.example.first.dto.BoardDto" resultMap="boardResultMap">
        SELECT * FROM postgres.first_project.boards
        WHERE board_id = #{boardId};
    </select>

    <!-- 게시글 생성 쿼리 -->
    <select id="createBoard" parameterType="com.example.first.dto.BoardDto" resultType="java.lang.Long">
        INSERT INTO postgres.first_project.boards (title, content, status, created_at, user_id, username, nickname)
        VALUES (#{title}, #{content}, #{status}, #{createdAt}, #{userId}, #{username}, #{nickname})
        RETURNING board_id;
    </select>

    <!-- 게시글 수정 쿼리 -->
    <update id="updateBoard" parameterType="com.example.first.dto.BoardDto">
        UPDATE postgres.first_project.boards
        SET title = #{title}, content = #{content}, status = #{status}, created_at = #{createdAt}, user_id = #{userId}
        WHERE board_id = #{boardId};
    </update>

    <!-- 게시글 삭제 쿼리 -->
    <delete id="deleteBoard" parameterType="java.lang.Long">
        DELETE FROM postgres.first_project.boards WHERE board_id = #{boardId};
    </delete>

    <!-- 게시글 검색 쿼리 -->
    <select id="getSearchBoards" parameterType="java.lang.String" resultType="com.example.first.dto.BoardDto" resultMap="boardResultMap">
        SELECT *
        FROM postgres.first_project.boards
        WHERE
            (title LIKE CONCAT('%', #{keyword}, '%') OR content LIKE CONCAT('%', #{keyword}, '%'));
    </select>

    <!-- 특정 게시글의 댓글 조회 쿼리 -->
    <select id="getAllCommentsByBoardId" parameterType="java.lang.Long" resultType="com.example.first.dto.CommentDto" resultMap="CommentResultMap">
        SELECT * FROM postgres.first_project.comments
        WHERE board_id = #{boardId};
    </select>

    <!-- 모든 게시글의 댓글 조회 쿼리 -->
    <select id="getAllComments"  resultType="com.example.first.dto.CommentDto" resultMap="CommentResultMap">
        SELECT * FROM postgres.first_project.comments;
    </select>

    <!-- 계층형 댓글 조회 쿼리 -->
    <select id="getHierarchicalCommentsByBoardId" parameterType="java.lang.Long" resultType="com.example.first.dto.CommentDto">
        WITH RECURSIVE CommentHierarchy(commentId, boardId, content, createdAt, username, nickname, parentCommentId, status, level, path, cycle) AS (
            SELECT
                b.comment_id AS commentId,
                b.board_id AS boardId,
                b.content,
                b.created_at AS createdAt,
                b.username,
                b.nickname,
                b.parent_comment_id AS parentCommentId,
                b.status,
                1,
                array[comment_id],
                false
            FROM
                postgres.first_project.comments b
            WHERE
                board_id = #{boardId}
            AND parent_comment_id IS NULL -- 최상위 댓글만 시작점으로
            UNION all
            SELECT
                c.comment_id AS commentId,
                c.board_id AS boardId,
                c.content,
                c.created_at AS createdAt,
                c.username,
                c.nickname,
                c.parent_comment_id AS parentCommentId,
                c.status,
                ch.level+1,
                array_append(ch.path, c.comment_id),
                c.comment_id = any(ch.path)
            from postgres.first_project.comments c
            INNER JOIN CommentHierarchy ch
            ON c.parent_comment_id = ch.commentId
            WHERE c.parent_comment_id  = ch.commentId
            AND NOT CYCLE
        )
        SELECT DISTINCT ON (path) -- 중복 제거를 commentId와 path에 적용
            commentId,
            boardId,
            lpad(' ', level) || content as content,
            createdAt,
            username,
            nickname,
            parentCommentId,
            status,
            path,
            level
        FROM
            CommentHierarchy
        ORDER BY
            path;

    </select>

    <!-- 테이블의 레벨 업데이트 쿼리 -->
    <update id="updateBoardLevel" parameterType="com.example.first.dto.CommentDto">
        UPDATE postgres.first_project.comments
        SET level = #{level}
        WHERE comment_id = #{commentId};
    </update>


    <!-- 댓글 생성 쿼리 -->
    <insert id="createComment" parameterType="com.example.first.dto.CommentDto" >
        INSERT INTO postgres.first_project.comments (board_id, content, username,nickname, created_at, parent_comment_id)
        VALUES (#{boardId}, #{content}, #{username}, #{nickname}, #{createdAt}, #{parentCommentId})
            RETURNING comment_id;
    </insert>

    <!-- 댓글 수정 쿼리 -->
    <update id="updateComment" parameterType="java.lang.Long">
        UPDATE postgres.first_project.comments
        SET content = #{content}
        WHERE comment_id = #{commentId}
    </update>

    <!-- 댓글 삭제 쿼리 -->
    <delete id="deleteComment" parameterType="java.lang.Long">
        DELETE FROM postgres.first_project.comments WHERE comment_id = #{commentId};
    </delete>

</mapper>
