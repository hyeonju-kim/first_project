<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!-- 게시판 -->
<mapper namespace="com.example.first.mapper.BoardMapper">

    <resultMap id="boardResultMap" type="com.example.first.dto.BoardDto">
        <id property="boardId" column="board_id"/>
        <result property="userId" column="user_id"/>
        <result property="createdAt" column="created_at"/>
        <result property="fileLocation" column="file_location"/>
        <result property="fileOriginalName" column="file_original_name"/>
        <result property="cntLike" column="cnt_like"/>
        <result property="likeYN" column="like_yn"/>

    </resultMap>

    <resultMap id="CommentResultMap" type="com.example.first.dto.CommentDto">
        <id property="commentId" column="comment_id"/>
        <result property="boardId" column="board_id"/>
        <result property="parentCommentId" column="parent_comment_id"/>
        <result property="createdAt" column="created_at"/>
    </resultMap>

    <resultMap id="BoardMultiFileResultMap" type="com.example.first.dto.BoardMultiFile">
        <id property="fileId" column="seq"/>
        <result property="boardId" column="board_id"/>
        <result property="fileName" column="file_name"/>
        <result property="savePath" column="save_path"/>
        <result property="regDate" column="reg_date"/>
        <result property="fileSize" column="file_size"/>
        <result property="flagDel" column="flag_del"/>
        <result property="fileExt" column="file_ext"/>
        <result property="fileOriginalName" column="file_original_name"/>
    </resultMap>

    <resultMap id="DietResultMap" type="com.example.first.dto.DietDto">
        <id property="seq" column="seq"/>
        <result property="intakeDate" column="intake_date"/>
        <result property="username" column="username"/>
        <result property="intakeResult" column="intake_result"/>
        <result property="foodNameMorning" column="food_name_morning" />
        <result property="foodNameLunch" column="food_name_lunch"/>
        <result property="foodNameDinner" column="food_name_dinner"/>
        <result property="foodNameSnack" column="food_name_snack"/>
        <result property="intakeCaloriesMorning" column="intake_calories_morning"/>
        <result property="intakeCaloriesLunch" column="intake_calories_lunch"/>
        <result property="intakeCaloriesDinner" column="intake_calories_dinner"/>
        <result property="intakeCaloriesSnack" column="intake_calories_snack"/>
        <result property="intakeTotal" column="intake_total"/>
    </resultMap>

    <resultMap id="BoardLikeResultMap" type="com.example.first.dto.BoardLikeDto">
        <id property="seq" column="seq"/>
        <result property="boardId" column="board_id"/>
        <result property="username" column="username"/>
    </resultMap>


<!--    페이지 별 게시판 글목록 조회-->
    <select id="getBoardsByPage" parameterType="map" resultType="com.example.first.dto.BoardDto" resultMap="boardResultMap">
        SELECT *
        FROM postgres.first_project.boards
        WHERE status = 'N'
        ORDER BY created_at DESC
        LIMIT #{pageSize} OFFSET #{offset};
    </select>

<!--    총 페이지 수 조회-->
    <select id="getTotalPages" parameterType="int" resultType="int">
        SELECT CEIL(COUNT(*)::NUMERIC / #{pageSize})
        FROM postgres.first_project.boards;
    </select>


    <!-- 특정 게시글 조회 쿼리 -->
    <select id="getBoardById" parameterType="java.lang.Long" resultType="com.example.first.dto.BoardDto" resultMap="boardResultMap">
        SELECT * FROM postgres.first_project.boards
        WHERE board_id = #{boardId};
    </select>

    <!-- 게시글 생성 쿼리 -->
    <select id="createBoard" parameterType="com.example.first.dto.BoardDto" resultType="java.lang.Long">
        INSERT INTO postgres.first_project.boards (title, content, status, created_at, user_id, username, nickname)
        VALUES (#{title}, #{content}, #{status}, #{createdAt}, #{userId}, #{username}, #{nickname})
        RETURNING board_id;
    </select>

    <!-- 좋아요 시 게시글 좋아요 수 업데이트 쿼리 -->
    <update id="updateBoardLikes" parameterType="com.example.first.dto.BoardDto">
        UPDATE postgres.first_project.boards
        SET cnt_like = #{cntLike}
        WHERE board_id = #{boardId};
    </update>

    <!-- 좋아요 시 좋아요 테이블에 인서트 -->
    <select id="saveBoardLike" parameterType="com.example.first.dto.BoardLikeDto" >
        INSERT INTO postgres.first_project.board_like (board_id, username)
        VALUES ( #{boardId}, #{username})
    </select>

    <!-- 좋아요 다시 누르면 좋아요 테이블에서 삭제 -->
    <select id="deleteBoardLike" parameterType="java.lang.String" >
        DELETE FROM postgres.first_project.board_like
        WHERE username = #{username};
    </select>

    <!-- 게시글 좋아요 되어있는지 확인-->
    <select id="findBoardLike" parameterType="java.lang.String" resultType="com.example.first.dto.BoardLikeDto" resultMap="BoardLikeResultMap">
        SELECT * FROM postgres.first_project.board_like
        WHERE username = #{username};
    </select>


    <!--멀티파일 업로드 (단일) - 반복문 돌면서 저장할 때 필요함 -->
    <select id="storeBoardMultiFile" parameterType="com.example.first.dto.BoardMultiFile" >
        INSERT INTO postgres.first_project.board_multi_file (board_id, file_name, save_path, reg_date, flag_del, file_ext, username, file_original_name, status)
        VALUES ( #{boardId}, #{fileName}, #{savePath}, #{regDate}, #{flagDel}, #{fileExt}, #{username}, #{fileOriginalName}, #{status})
    </select>

    <!-- 멀티파일 업로드 (다중) -->
    <insert id="storeBoardMultiFiles" parameterType="list">
        INSERT INTO postgres.first_project.board_multi_file (
        board_id, file_name, save_path, reg_date, flag_del, file_ext, username, file_original_name, status
        )
        VALUES
        <foreach item="file" collection="list" separator=",">
            (
            #{file.boardId},
            #{file.fileName},
            #{file.savePath},
            #{file.regDate},
            #{file.flagDel},
            #{file.fileExt},
            #{file.username},
            #{file.fileOriginalName},
            #{file.status}
            )
        </foreach>
    </insert>

    <!-- 멀티파일 삭제 (flagDel = "Y" 로) -->
    <update id="updateMultiFilesFlagDel" parameterType="com.example.first.dto.BoardMultiFile"  >
        UPDATE postgres.first_project.board_multi_file
        SET flag_del = 'Y'
        WHERE file_original_name = #{file_original_name};
    </update>


    <!-- 특정 게시글의 모든 멀티파일 file_original_name 조회 쿼리 -->
    <select id="findAllMultiFilesName" parameterType="java.lang.Long" resultType="String" >
        SELECT file_original_name
        FROM postgres.first_project.board_multi_file
        WHERE board_id = #{boardId}
        AND flag_del = 'N';
    </select>





    <!-- 게시글 수정 쿼리 -->
    <update id="updateBoard" parameterType="com.example.first.dto.BoardDto">
        UPDATE postgres.first_project.boards
        SET title = #{title}, content = #{content}, status = #{status}, created_at = #{createdAt}, user_id = #{userId}
        WHERE board_id = #{boardId};
    </update>


    <!-- 게시글 삭제 쿼리 -->
    <delete id="deleteBoard" parameterType="java.lang.Long">
        UPDATE postgres.first_project.boards
        SET status = 'Y'
        WHERE board_id = #{boardId};
    </delete>

    <!-- 게시글 검색  (페이징 적용) -->
    <select id="getSearchBoardsByPage" parameterType="map" resultType="com.example.first.dto.BoardDto" resultMap="boardResultMap">
        SELECT *
        FROM postgres.first_project.boards
        WHERE status = 'N'
        AND
            (title LIKE CONCAT('%', #{keyword}, '%') OR content LIKE CONCAT('%', #{keyword}, '%'))
        ORDER BY created_at DESC
            LIMIT #{pageSize} OFFSET #{offset};
    </select>

    <!--   검색된 글의 총 페이지 수 조회 (페이징 적용) -->
    <select id="getSearchBoardsTotalPages" parameterType="map" resultType="int">
        SELECT CEIL(COUNT(*)::NUMERIC / #{pageSize})
        FROM postgres.first_project.boards
        WHERE status = 'N'
          AND
            (title LIKE CONCAT('%', #{keyword}, '%') OR content LIKE CONCAT('%', #{keyword}, '%'));
    </select>

    <!-- 특정 게시글의 댓글 조회 쿼리 -->
    <select id="getAllCommentsByBoardId" parameterType="java.lang.Long" resultType="com.example.first.dto.CommentDto" resultMap="CommentResultMap">
        SELECT * FROM postgres.first_project.comments
        WHERE board_id = #{boardId};
    </select>

    <!-- 모든 게시글의 댓글 조회 쿼리 -->
    <select id="getAllComments"  resultType="com.example.first.dto.CommentDto" resultMap="CommentResultMap">
        SELECT * FROM postgres.first_project.comments
        WHERE status = 'N';
    </select>

    <!-- 계층형 댓글 조회 쿼리 -->
    <select id="getHierarchicalCommentsByBoardId" parameterType="java.lang.Long" resultType="com.example.first.dto.CommentDto">
        WITH RECURSIVE CommentHierarchy(commentId, boardId, content, createdAt, username, nickname, parentCommentId, status, level, path, cycle) AS (
            SELECT
                b.comment_id AS commentId,
                b.board_id AS boardId,
                b.content,
                b.created_at AS createdAt,
                b.username,
                b.nickname,
                b.parent_comment_id AS parentCommentId,
                b.status,
                1,
                array[comment_id],
                false
            FROM
                postgres.first_project.comments b
            WHERE
                board_id = #{boardId}
              AND
                parent_comment_id IS NULL -- 최상위 댓글만 시작점으로
              AND
                status = 'N'
            UNION all
            SELECT
                c.comment_id AS commentId,
                c.board_id AS boardId,
                c.content,
                c.created_at AS createdAt,
                c.username,
                c.nickname,
                c.parent_comment_id AS parentCommentId,
                c.status,
                ch.level+1,
                array_append(ch.path, c.comment_id),
                c.comment_id = any(ch.path)
            from postgres.first_project.comments c
            INNER JOIN CommentHierarchy ch
            ON c.parent_comment_id = ch.commentId
            WHERE c.parent_comment_id  = ch.commentId
            AND NOT CYCLE
        )
        SELECT DISTINCT ON (path)
            commentId,
            boardId,
            lpad(' ', level) || content as content,
            createdAt,
            username,
            nickname,
            parentCommentId,
            status,
            path,
            level
        FROM
            CommentHierarchy
        WHERE
            status = 'N'
        ORDER BY
            path;

    </select>

    <!-- 테이블의 레벨 업데이트 쿼리 -->
    <update id="updateBoardLevel" parameterType="com.example.first.dto.CommentDto">
        UPDATE postgres.first_project.comments
        SET level = #{level}
        WHERE comment_id = #{commentId};
    </update>


    <!-- 댓글 생성 쿼리 -->
    <insert id="createComment" parameterType="com.example.first.dto.CommentDto" >
        INSERT INTO postgres.first_project.comments (board_id, content, username,nickname, created_at, parent_comment_id, status)
        VALUES (#{boardId}, #{content}, #{username}, #{nickname}, #{createdAt}, #{parentCommentId}, #{status})
            RETURNING comment_id;
    </insert>

    <!-- 댓글 수정 쿼리 -->
    <update id="updateComment" parameterType="java.lang.Long">
        UPDATE postgres.first_project.comments
        SET content = #{content}
        WHERE comment_id = #{commentId}
    </update>

    <!-- 댓글 삭제 쿼리 -->
    <delete id="deleteComment" parameterType="java.lang.Long">
        UPDATE postgres.first_project.comments
        SET status = 'Y'
        WHERE comment_id = #{commentId};
    </delete>

    <!--특정 댓글 하나 select-->
    <select id="findCommentByCommentId" parameterType="java.lang.Long" resultType="com.example.first.dto.CommentDto" >
        SELECT *
        FROM postgres.first_project.comments
        WHERE comment_id = #{commentId}
          AND status = 'N'
    </select>


    <!-- boardId로 멀티파일 원본 이름 가져오기 -->
    <select id="findBoardMultiFileOriginalName" parameterType="java.lang.Long" resultType="java.lang.String" >
        SELECT file_original_name
        FROM postgres.first_project.board_multi_file
        WHERE board_id = #{boardId}
        AND status = 'N'
        ORDER BY reg_date DESC -- created_at 열을 내림차순으로 정렬합니다.
            LIMIT 1 -- 결과를 하나만 가져오도록 제한합니다.
    </select>

    <!-- boardId로 멀티파일 경로 가져오기 -->
    <select id="findBoardMultiFileSavePath" parameterType="java.lang.Long" resultType="java.lang.String" >
        SELECT save_path
        FROM postgres.first_project.board_multi_file
        WHERE board_id = #{boardId}
          AND status = 'N'
        ORDER BY reg_date DESC -- created_at 열을 내림차순으로 정렬합니다.
            LIMIT 1 -- 결과를 하나만 가져오도록 제한합니다.
    </select>

    <!-- boardId로 멀티파일 파일명 가져오기 -->
    <select id="findBoardMultiFileFileName" parameterType="java.lang.Long" resultType="java.lang.String" >
        SELECT file_name
        FROM postgres.first_project.board_multi_file
        WHERE board_id = #{boardId}
          AND status = 'N'
    </select>

    <!-- boardId로 멀티파일 객체 리스트 가져오기 -->
    <select id="findBoardMultiFileByBoardId" parameterType="java.lang.Long" resultType="com.example.first.dto.BoardMultiFile" resultMap="BoardMultiFileResultMap">
        SELECT *
        FROM postgres.first_project.board_multi_file
        WHERE board_id = #{boardId}
          AND status = 'N'
    </select>

    <!-- fileId로 멀티파일 객체 가져와서 다운로드 (게시물에서 클릭 시 )-->
    <select id="findBoardMultiFileBySeq" parameterType="java.lang.Long" resultType="com.example.first.dto.BoardMultiFile" resultMap="BoardMultiFileResultMap">
        SELECT *
        FROM postgres.first_project.board_multi_file
        WHERE seq = #{fileId}
          AND status = 'N'
    </select>

    <!-- 식이 저장 쿼리 -->
    <select id="insertDietRecord" parameterType="com.example.first.dto.DietDto" >
        INSERT INTO postgres.first_project.diet (intake_date, intake_calories_morning, intake_calories_lunch, intake_calories_dinner, intake_result, intake_total, username)
        VALUES (#{intakeDate}, #{intakeCaloriesMorning}, #{intakeCaloriesLunch}, #{intakeCaloriesDinner},#{intakeResult}, #{intakeTotal}, #{username})
    </select>



    <!-- username으로 모든 식이 리스트 가져오기 -->
    <select id="findDietListByUsername" parameterType="java.lang.String" resultType="hashmap">
        SELECT *
        FROM postgres.first_project.diet
        WHERE username = #{username}
        ORDER BY intake_date;
    </select>

    <!-- username으로 오늘의 식이 리스트 가져오기 -->
    <select id="findDietListByUsernameDaily" parameterType="java.lang.String" resultType="com.example.first.dto.DietDto" resultMap="DietResultMap">
        SELECT *
        FROM postgres.first_project.diet
        WHERE username = #{username}
          AND DATE(intake_date) = CURRENT_DATE;
    </select>

    <!-- username으로 일주일치 식이 리스트 가져오기 -->
    <select id="findDietListByUsernameWeekly" parameterType="java.lang.String" resultType="com.example.first.dto.DietDto" resultMap="DietResultMap">
        <![CDATA[
        SELECT *
        FROM postgres.first_project.diet
        WHERE username = #{username}
          AND DATE(intake_date) >= CURRENT_DATE - INTERVAL '7 days'
          AND DATE(intake_date) <= CURRENT_DATE
        ORDER BY intake_date;
        ]]>
    </select>

    <!-- 모든 유저 식이 기록 최근 7일 조회 (적정 횟수 카운트, 유저네임, 적정 횟수가 많은 순으로 조회) -->
    <select id="findAllUserDietListWeekly" resultType="hashmap">
        <![CDATA[
        SELECT COUNT(intake_result) AS result_good_count, username
        FROM postgres.first_project.diet
        WHERE DATE (intake_date) >= CURRENT_DATE - INTERVAL '6 days'
          AND DATE (intake_date) <= CURRENT_DATE
          AND intake_result = '적정'
        GROUP BY username
        ORDER BY result_good_count DESC;
        ]]>
    </select>







</mapper>
