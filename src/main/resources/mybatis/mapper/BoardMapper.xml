<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!-- 게시판 -->
<mapper namespace="com.example.first.mapper.BoardMapper">

    <resultMap id="boardResultMap" type="com.example.first.dto.BoardDto">
        <id property="boardId" column="board_id"/>
        <result property="userId" column="user_id"/>
        <result property="createdAt" column="created_at"/>
        <result property="fileLocation" column="file_location"/>
        <result property="fileOriginalName" column="file_original_name"/>

    </resultMap>

    <resultMap id="CommentResultMap" type="com.example.first.dto.CommentDto">
        <id property="commentId" column="comment_id"/>
        <result property="boardId" column="board_id"/>
        <result property="parentCommentId" column="parent_comment_id"/>
        <result property="createdAt" column="created_at"/>
    </resultMap>

    <resultMap id="BoardMultiFileResultMap" type="com.example.first.dto.BoardMultiFile">
        <id property="fileId" column="seq"/>
        <result property="boardId" column="board_id"/>
        <result property="fileName" column="file_name"/>
        <result property="savePath" column="save_path"/>
        <result property="regDate" column="reg_date"/>
        <result property="fileSize" column="file_size"/>
        <result property="flagDel" column="flag_del"/>
        <result property="fileExt" column="file_ext"/>
        <result property="fileOriginalName" column="file_original_name"/>
    </resultMap>

    <!-- 게시글 목록 조회 쿼리 -->
    <select id="getAllBoards" resultType="com.example.first.dto.BoardDto" resultMap="boardResultMap">
        SELECT * FROM postgres.first_project.boards
        ORDER BY created_at DESC;
    </select>


<!--    페이지 별 게시판 글목록 조회-->
    <select id="getBoardsByPage" parameterType="map" resultType="com.example.first.dto.BoardDto" resultMap="boardResultMap">
        SELECT *
        FROM postgres.first_project.boards
        ORDER BY created_at DESC
        LIMIT #{pageSize} OFFSET #{offset};
    </select>

<!--    총 페이지 수 조회-->
    <select id="getTotalPages" parameterType="int" resultType="int">
        SELECT CEIL(COUNT(*)::NUMERIC / #{pageSize})
        FROM postgres.first_project.boards;
    </select>


    <!-- 특정 게시글 조회 쿼리 -->
    <select id="getBoardById" parameterType="java.lang.Long" resultType="com.example.first.dto.BoardDto" resultMap="boardResultMap">
        SELECT * FROM postgres.first_project.boards
        WHERE board_id = #{boardId};
    </select>

    <!-- 게시글 생성 쿼리 -->
    <select id="createBoard" parameterType="com.example.first.dto.BoardDto" resultType="java.lang.Long">
        INSERT INTO postgres.first_project.boards (title, content, status, created_at, user_id, username, nickname)
        VALUES (#{title}, #{content}, #{status}, #{createdAt}, #{userId}, #{username}, #{nickname})
        RETURNING board_id;
    </select>

    <!--멀티파일 업로드 (단일) -->
    <select id="storeBoardMultiFile" parameterType="com.example.first.dto.BoardMultiFile" >
        INSERT INTO postgres.first_project.board_multi_file (board_id, file_name, save_path, reg_date, flag_del, file_ext, username, file_original_name)
        VALUES ( #{boardId}, #{fileName}, #{savePath}, #{regDate}, #{flagDel}, #{fileExt}, #{username}, #{fileOriginalName})
    </select>

    <!-- 멀티파일 업로드 (다중) -->
    <insert id="storeBoardMultiFiles" parameterType="list">
        INSERT INTO postgres.first_project.board_multi_file (
        board_id, file_name, save_path, reg_date, flag_del, file_ext, username, file_original_name
        )
        VALUES
        <foreach item="file" collection="list" separator=",">
            (
            #{file.boardId},
            #{file.fileName},
            #{file.savePath},
            #{file.regDate},
            #{file.flagDel},
            #{file.fileExt},
            #{file.username},
            #{file.fileOriginalName}
            )
        </foreach>
    </insert>


    <!-- 게시글 수정 쿼리 -->
    <update id="updateBoard" parameterType="com.example.first.dto.BoardDto">
        UPDATE postgres.first_project.boards
        SET title = #{title}, content = #{content}, status = #{status}, created_at = #{createdAt}, user_id = #{userId}
        WHERE board_id = #{boardId};
    </update>

    <!-- 게시글 삭제 쿼리 -->
    <delete id="deleteBoard" parameterType="java.lang.Long">
        DELETE FROM postgres.first_project.boards WHERE board_id = #{boardId};
    </delete>

    <!-- 게시글 검색 쿼리 -->
    <select id="getSearchBoards" parameterType="java.lang.String" resultType="com.example.first.dto.BoardDto" resultMap="boardResultMap">
        SELECT *
        FROM postgres.first_project.boards
        WHERE
            (title LIKE CONCAT('%', #{keyword}, '%') OR content LIKE CONCAT('%', #{keyword}, '%'));
    </select>

    <!-- 특정 게시글의 댓글 조회 쿼리 -->
    <select id="getAllCommentsByBoardId" parameterType="java.lang.Long" resultType="com.example.first.dto.CommentDto" resultMap="CommentResultMap">
        SELECT * FROM postgres.first_project.comments
        WHERE board_id = #{boardId};
    </select>

    <!-- 모든 게시글의 댓글 조회 쿼리 -->
    <select id="getAllComments"  resultType="com.example.first.dto.CommentDto" resultMap="CommentResultMap">
        SELECT * FROM postgres.first_project.comments;
    </select>

    <!-- 계층형 댓글 조회 쿼리 -->
    <select id="getHierarchicalCommentsByBoardId" parameterType="java.lang.Long" resultType="com.example.first.dto.CommentDto">
        WITH RECURSIVE CommentHierarchy(commentId, boardId, content, createdAt, username, nickname, parentCommentId, status, level, path, cycle) AS (
            SELECT
                b.comment_id AS commentId,
                b.board_id AS boardId,
                b.content,
                b.created_at AS createdAt,
                b.username,
                b.nickname,
                b.parent_comment_id AS parentCommentId,
                b.status,
                1,
                array[comment_id],
                false
            FROM
                postgres.first_project.comments b
            WHERE
                board_id = #{boardId}
            AND parent_comment_id IS NULL -- 최상위 댓글만 시작점으로
            UNION all
            SELECT
                c.comment_id AS commentId,
                c.board_id AS boardId,
                c.content,
                c.created_at AS createdAt,
                c.username,
                c.nickname,
                c.parent_comment_id AS parentCommentId,
                c.status,
                ch.level+1,
                array_append(ch.path, c.comment_id),
                c.comment_id = any(ch.path)
            from postgres.first_project.comments c
            INNER JOIN CommentHierarchy ch
            ON c.parent_comment_id = ch.commentId
            WHERE c.parent_comment_id  = ch.commentId
            AND NOT CYCLE
        )
        SELECT DISTINCT ON (path)
            commentId,
            boardId,
            lpad(' ', level) || content as content,
            createdAt,
            username,
            nickname,
            parentCommentId,
            status,
            path,
            level
        FROM
            CommentHierarchy
        ORDER BY
            path;

    </select>

    <!-- 테이블의 레벨 업데이트 쿼리 -->
    <update id="updateBoardLevel" parameterType="com.example.first.dto.CommentDto">
        UPDATE postgres.first_project.comments
        SET level = #{level}
        WHERE comment_id = #{commentId};
    </update>


    <!-- 댓글 생성 쿼리 -->
    <insert id="createComment" parameterType="com.example.first.dto.CommentDto" >
        INSERT INTO postgres.first_project.comments (board_id, content, username,nickname, created_at, parent_comment_id)
        VALUES (#{boardId}, #{content}, #{username}, #{nickname}, #{createdAt}, #{parentCommentId})
            RETURNING comment_id;
    </insert>

    <!-- 댓글 수정 쿼리 -->
    <update id="updateComment" parameterType="java.lang.Long">
        UPDATE postgres.first_project.comments
        SET content = #{content}
        WHERE comment_id = #{commentId}
    </update>

    <!-- 댓글 삭제 쿼리 -->
    <delete id="deleteComment" parameterType="java.lang.Long">
        DELETE FROM postgres.first_project.comments WHERE comment_id = #{commentId};
    </delete>


    <!-- boardId로 멀티파일 이름 가져오기 -->
    <select id="findBoardMultiFileOriginalName" parameterType="java.lang.Long" resultType="java.lang.String" >
        SELECT file_original_name
        FROM postgres.first_project.board_multi_file
        WHERE board_id = #{boardId}
        ORDER BY reg_date DESC -- created_at 열을 내림차순으로 정렬합니다.
            LIMIT 1 -- 결과를 하나만 가져오도록 제한합니다.
    </select>

    <!-- boardId로 멀티파일 경로 가져오기 -->
    <select id="findBoardMultiFileSavePath" parameterType="java.lang.Long" resultType="java.lang.String" >
        SELECT save_path
        FROM postgres.first_project.board_multi_file
        WHERE board_id = #{boardId}
        ORDER BY reg_date DESC -- created_at 열을 내림차순으로 정렬합니다.
            LIMIT 1 -- 결과를 하나만 가져오도록 제한합니다.
    </select>

    <!-- boardId로 멀티파일 파일명 가져오기 -->
    <select id="findBoardMultiFileFileName" parameterType="java.lang.Long" resultType="java.lang.String" >
        SELECT file_name
        FROM postgres.first_project.board_multi_file
        WHERE board_id = #{boardId}
    </select>

    <!-- boardId로 멀티파일 객체 (단일) 가져오기 -->
    <select id="findBoardMultiFileByBoardId" parameterType="java.lang.Long" resultType="com.example.first.dto.BoardMultiFile" resultMap="BoardMultiFileResultMap">
        SELECT *
        FROM postgres.first_project.board_multi_file
        WHERE board_id = #{boardId}
    </select>

    <!-- fileId로 멀티파일 객체 가져오기 -->
    <select id="findBoardMultiFileBySeq" parameterType="java.lang.Long" resultType="com.example.first.dto.BoardMultiFile" resultMap="BoardMultiFileResultMap">
        SELECT *
        FROM postgres.first_project.board_multi_file
        WHERE seq = #{fileId}
    </select>





</mapper>
